/*   pragma 키워드   */

/*
#pragma 는 컴파일러에게 말하는 전처리기 명령 이라고 보시면 됩니다. 
즉, #include 나 #define 처럼 전처리기에 의해 컴파일 이전에 처리되지만, 
그 명령은 컴파일러에게 전달되기 때문이죠.

사실 pragma 는 C 언어의 기본 키워드라고 하기 보다는, 
컴파일러에 종속적인 키워드라고 하는 것이 맞습니다. 
pragma 를 사용하는 문법은 컴파일러 마다 다르고 딱히 통일 된 것이 없기 때문입니다. 
이 강좌에서는 pragma 를 사용하는 몇 가지 예제들을 보고 
어떤 경우에 편리하게 pragma 를 사용할 수 있는지 살펴봅시다.
*/

// #include <stdio.h>
// struct Weird{
//     char arr[2];
//     int i;
// };

// int main() {
//     struct Weird a;
//     printf("size of a : %d \n",sizeof(a));
//     return 0;
// }
/*
상당히 이상하지요. 
분명히 Weird 구조체 내의 원소들의 총 바이트 수를 계산해보면 
arr 은 char 형 변수 2 개로 2 바이트 이고, 
i 는 int 형 변수 1 개로 4 바이트 이므로 6 이 나와야 정상이지요. 
그런데 도대체 왜 컴퓨터는 이를 8 로 출력했을까요?

왜냐하면 실제로 메모리 상에서 위 구조체의 크기를 8 바이트로 컴파일러가 지정하였기 때문입니다.
현재 우리가 사용하는 컴퓨터에서는 언제나 4 바이트 단위로 모든 것을 처리하는 것이 빠릅니다. 
따라서 언제나 컴퓨터에서 데이터를 보관할 때 에는 4의 배수로 데이터를 보관하는 것이 처리시 용이하게 됩니다. 
이렇게 데이터가 4 의 배수 경계에 놓인 것을 더블 워드 경계에 놓여 있다 라고 합니다.

*/

#include <stdio.h>
/* 전처리기 명령에는 ; 를 붙이지 않는다. */
#pragma pack(1) // 더블워드 경계에 놓이지 마라는 표시
struct Weird {
    char arr[2];
    int i;
};

int main(){
    struct Weird a;
    printf("size of a : %d \n",sizeof(a));

    return 0;
}


/*
pragma once 를 이용하면 한 번 include 되었다면 
헤더파일을 다시 열어보지도 않기 때문에 컴파일 시간이 절약되는 효과가 나게 됩니다.

다만 앞에서도 말했듯이 #pragma 관련 키워드들이 
컴파일러 종속적이여서 어떤 컴파일러에서는 #pragma once 가 지원이 되지 않을 수 도 있습니다. 
따라서 무슨 컴파일러를 사용하는지 보고 #pragma once 를 지원한다면 되도록 이것을 사용하는 것이 도움이 됩니다.


*/



